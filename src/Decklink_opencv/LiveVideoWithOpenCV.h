/* -LICENSE-START-
 ** Copyright (c) 2018 Blackmagic Design
 **
 ** Permission is hereby granted, free of charge, to any person or organization
 ** obtaining a copy of the software and accompanying documentation covered by
 ** this license (the "Software") to use, reproduce, display, distribute,
 ** execute, and transmit the Software, and to prepare derivative works of the
 ** Software, and to permit third-parties to whom the Software is furnished to
 ** do so, all subject to the following:
 **
 ** The copyright notices in the Software and this entire statement, including
 ** the above license grant, this restriction and the following disclaimer,
 ** must be included in all copies of the Software, in whole or in part, and
 ** all derivative works of the Software, unless such copies or derivative
 ** works are solely in the form of machine-executable object code generated by
 ** a source language processor.
 **
 ** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 ** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 ** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 ** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 ** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 ** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 ** DEALINGS IN THE SOFTWARE.
 ** -LICENSE-END-
 */
#pragma once

#include <chrono>
#include <cstdio>
#include <thread>
#include <vector>

#include "DeckLinkAPI.h"
#include <opencv2/opencv.hpp>
#include "com_ptr.h"
#include "DeviceManager.h"

#define xstr(a) str(a)  // stringify macros
#define str(a) #a

// OPENCV_DIR should point to directory where OpenCV has been installed
#ifndef _WIN32
#define CLASSIFIER_BASE_PATH xstr(OPENCV_DIR)
#else
#define CLASSIFIER_BASE_PATH xstr(OPENCV_DIR) "/etc"
#endif

std::string hrToString(HRESULT hr)
{
	switch (hr)
	{
		case S_OK: return "S_OK";
		case S_FALSE: return "S_FALSE";
		case E_UNEXPECTED: return "E_UNEXPECTED";
		case E_NOTIMPL: return "E_NOTIMPL";
		case E_OUTOFMEMORY: return "E_OUTOFMEMORY";
		case E_INVALIDARG: return "E_INVALIDARG";
		case E_NOINTERFACE: return "E_NOINTERFACE";
		case E_POINTER: return "E_POINTER";
		case E_HANDLE: return "E_HANDLE";
		case E_ABORT: return "E_ABORT";
		case E_FAIL: return "E_FAIL";
		case E_ACCESSDENIED: return "E_ACCESSDENIED";
		default: return "<unknown hr>";
	}
}

// Macro to make calling COM API easier to read and to throw an exception on failure
#define CHECK_API(x)                                                                                                             \
	{                                                                                                                            \
		HRESULT hr;                                                                                                              \
		if (FAILED(hr = x)) throw std::runtime_error("API call " #x " failed: hr=" + std::to_string(hr) + " " + hrToString(hr)); \
	}

enum ProcessMode
{
	kProcessModeBlack,
	kProcessModeLoopThrough,
	kProcessModeGrayScale,
	kProcessModeResizeFiltered,
	kProcessModeResizeNearest,
	kProcessModeResizeTooSmall,
	kProcessModeDetectWithAnnotation,
	kProcessModeDetectWithAnnotationAndExtract
};

enum ProcessFlag
{
	kProcessFlagResizeScale,
	kProcessFlagFilterQuality,
};

enum class Detector
{
	FrontalFace,
	ProfileFace,
	UpperBody,
	FullBody,
	Smile,
	Eye
};

// Stabilizer is used to average a group of rects to avoid the jitter
// caused by detecting objects at a scaled down resolution.
class Stabilizer
{
public:
	void	 addRect(const cv::Rect& rect);
	size_t   count() const;
	cv::Rect average() const;

private:
	const uint32_t		 kNumFrames = 10;
	std::deque<cv::Rect> rects;
};

class Capture : private IDeckLinkInputCallback, private IDeckLinkVideoOutputCallback
{
public:
	static Capture* CreateInstance(com_ptr<IDeckLinkInput> deckLinkInput, com_ptr<IDeckLinkOutput> deckLinkOutput, BMDDisplayMode displayMode);
	void			StartDeckLinkCapture();
	void			StopDeckLinkCapture();
	void			setProcessMode(ProcessMode mode);
	void			toggleProcessFlag(ProcessFlag flag);
	void			setClassifier(Detector detector);

private:
	Capture(com_ptr<IDeckLinkInput> deckLinkInput, com_ptr<IDeckLinkOutput> deckLinkOutput, BMDDisplayMode displayMode);

	void getWidthHeightForDisplayMode(BMDDisplayMode displayMode, uint32_t& width, uint32_t& height, BMDTimeValue& frDuration, BMDTimeScale& frScale);

	// IUnknown
	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID iid, LPVOID* ppv) override;
	ULONG   STDMETHODCALLTYPE AddRef() override;
	ULONG   STDMETHODCALLTYPE Release() override;

	// IDeckLinkInputCallback
	HRESULT STDMETHODCALLTYPE VideoInputFormatChanged(BMDVideoInputFormatChangedEvents notificationEvents,
														IDeckLinkDisplayMode*			 newDisplayMode,
														BMDDetectedVideoInputFormatFlags detectedSignalFlags) override;

	// IDeckLinkVideoOutputCallback
	HRESULT STDMETHODCALLTYPE ScheduledFrameCompleted(IDeckLinkVideoFrame* completedFrame, BMDOutputFrameCompletionResult result) override;
	HRESULT STDMETHODCALLTYPE ScheduledPlaybackHasStopped() override;
	HRESULT STDMETHODCALLTYPE VideoInputFrameArrived(IDeckLinkVideoInputFrame* videoFrame, IDeckLinkAudioInputPacket* audioPacket) override;

private:
	BMDDisplayMode								m_displayMode;
	std::atomic<ULONG>							m_refCount;
	std::mutex									m_deckLinkInputMutex;
	com_ptr<IDeckLinkInput>						m_deckLinkInput;
	com_ptr<IDeckLinkOutput>					m_deckLinkOutput;
	com_ptr<IDeckLinkVideoConversion>			m_deckLinkVideoConversion;
	std::vector<IDeckLinkMutableVideoFrame*>	m_outputVideoFrameQueue;
	uint32_t									m_outputVideoFrameIndex;
	com_ptr<IDeckLinkMutableVideoFrame>			m_blackVideoFrame;
	BMDTimeScale								m_timeScale;
	ProcessMode									m_processMode;
	std::map<ProcessFlag, bool>					m_processFlag;
	Detector									m_detector;
	Stabilizer									m_stabilizer;

	std::map<Detector, cv::CascadeClassifier>	m_classifiers;
};
