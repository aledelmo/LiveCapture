/* -LICENSE-START-
 ** Copyright (c) 2018 Blackmagic Design
 **
 ** Permission is hereby granted, free of charge, to any person or organization
 ** obtaining a copy of the software and accompanying documentation covered by
 ** this license (the "Software") to use, reproduce, display, distribute,
 ** execute, and transmit the Software, and to prepare derivative works of the
 ** Software, and to permit third-parties to whom the Software is furnished to
 ** do so, all subject to the following:
 **
 ** The copyright notices in the Software and this entire statement, including
 ** the above license grant, this restriction and the following disclaimer,
 ** must be included in all copies of the Software, in whole or in part, and
 ** all derivative works of the Software, unless such copies or derivative
 ** works are solely in the form of machine-executable object code generated by
 ** a source language processor.
 **
 ** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 ** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 ** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 ** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 ** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 ** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 ** DEALINGS IN THE SOFTWARE.
 ** -LICENSE-END-
 */

#include <stdio.h>
#include <stdlib.h>
#include <atomic>
#include <mutex>
#include <condition_variable>
#include "platform.h"  // Simple cross-platform support for DeckLink API

// On macOS - Link with CoreFoundation.Framework

//1920*1080, 59.94Hz, 10bitYUV

// Video mode parameters
const BMDDisplayMode      kDisplayMode = bmdModeHD1080p5994;
const BMDVideoOutputFlags kOutputFlags = bmdVideoOutputFlagDefault;
const BMDPixelFormat      kPixelFormat = bmdFormat10BitYUV;

// Frame parameters
const uint32_t kFrameDuration	= 1001;
const uint32_t kTimeScale		= 60000;
const uint32_t kFrameWidth		= 1920;
const uint32_t kFrameHeight		= 1080;

// 10-bit YUV row bytes, ref. SDK Manual "2.7.4 Pixel Formats" / bmdFormat10BitYUV
const uint32_t kRowBytes = ((kFrameWidth + 47) / 48) * 128;

// 10-bit YUV colour pixels
const uint32_t kBlueData[] = { 0x40aa298, 0x2a8a62a8, 0x298aa040, 0x2a8102a8 };

// Video output completion result descriptions
static const char* kVideoOutputCompletionResult[] =
{
	"completed",
	"displayed late",
	"dropped",
	"flushed"
};

static void FillBlue(IDeckLinkMutableVideoFrame* theFrame)
{
	uint32_t* nextWord;
	uint32_t  wordsRemaining;

	theFrame->GetBytes((void**)&nextWord);
	wordsRemaining = (kRowBytes * kFrameHeight) / 4;

        while (wordsRemaining > 0)
        {
            *(nextWord++) = kBlueData[0];
            *(nextWord++) = kBlueData[1];
            *(nextWord++) = kBlueData[2];
		*(nextWord++) = kBlueData[3];
		wordsRemaining = wordsRemaining - 4;
	}
}

static IDeckLink* GetFirstDeckLink()
{
	IDeckLinkIterator*	deckLinkIterator = NULL;
	IDeckLink*			deckLink = NULL;
	std::string			deckLinkModelName;

	// Obtain an IDeckLinkIterator instance
	if (GetDeckLinkIterator(&deckLinkIterator) != S_OK)
		goto bail;

	// Obtain an IDeckLink instance for the first device on the system
	if (deckLinkIterator->Next(&deckLink) == S_OK)
	{
		dlstring_t modelName;
		deckLink->GetModelName(&modelName);
		deckLinkModelName = DlToStdString(modelName);
		printf("Using %s\n", deckLinkModelName.c_str());
		DeleteString(modelName);
	}

	if (deckLink == NULL)
	{
		fprintf(stderr, "No Desktop Video devices found.\n");
		goto bail;
	}
	return deckLink;

bail:
	// Release the DeckLink iterator
	if (deckLinkIterator != NULL)
	{
		deckLinkIterator->Release();
		deckLinkIterator = NULL;
	}
	return NULL;
}

static IDeckLinkMutableVideoFrame* CreateFrame(IDeckLinkOutput* deckLinkOutput)
{
	HRESULT                         result;
	IDeckLinkMutableVideoFrame*     frame = NULL;

	result = deckLinkOutput->CreateVideoFrame(kFrameWidth, kFrameHeight, kRowBytes, kPixelFormat, bmdFrameFlagDefault, &frame);
	if (result != S_OK)
	{
		fprintf(stderr, "Could not create video frame - result = %08x\n", result);
		goto bail;
	}
	
	FillBlue(frame);

bail:
	return frame;
}

class VideoOutput: public IDeckLinkVideoOutputCallback
{
private:
	std::atomic<ULONG>		m_refCount;
	IDeckLinkOutput*		m_deckLinkOutput;
	uint64_t				m_scheduledFrameCount;
	std::atomic<bool>		m_playbackRunning;
	std::mutex				m_mutex;
	std::condition_variable	m_stoppedCondition;

public:
	VideoOutput(IDeckLink* deckLink) :
		m_refCount(1), m_scheduledFrameCount(0), m_playbackRunning(false)
	{
		// Obtain the an IDeckLinkOutput instance for the DeckLink device
		HRESULT result = deckLink->QueryInterface(IID_IDeckLinkOutput, (void**)&m_deckLinkOutput);
		if (result != S_OK)
			fprintf(stderr, "Could not obtain IDeckLinkOutput - result = %08x\n", result);
	}

	virtual ~VideoOutput()
	{
		if (m_deckLinkOutput != NULL)
			m_deckLinkOutput->Release();
	}

	HRESULT EnableOutput()
	{
		HRESULT result;

		// Set the callback object to the DeckLink device's output interface
		result = m_deckLinkOutput->SetScheduledFrameCompletionCallback(this);
		if (result != S_OK)
		{
			fprintf(stderr, "Could not set scheduled frame completion callback - result = %08x\n", result);
			return result;
		}

		// Enable video output
		result = m_deckLinkOutput->EnableVideoOutput(kDisplayMode, kOutputFlags);
		if (result != S_OK)
			fprintf(stderr, "Could not enable video output - result = %08x\n", result);

		return result;
	}

	HRESULT PrerollAndStartScheduledPlayback()
	{
		HRESULT result;
		// Preroll 3 frames
		for (int i = 0; i < 3; i++)
		{
			IDeckLinkVideoFrame*    videoFrameBlue = NULL;

			videoFrameBlue = CreateFrame(m_deckLinkOutput);
			if (!videoFrameBlue)
				return E_FAIL;

			result = ScheduleNextFrame(videoFrameBlue);
			if (result != S_OK)
			{
				videoFrameBlue->Release();
				fprintf(stderr, "Could not schedule video frame - result = %08x\n", result);
				return result;
			}
		}

		// Start scheduled playback
		result = m_deckLinkOutput->StartScheduledPlayback(0, kTimeScale, 1.0);
		if (result != S_OK) 
		{
			fprintf(stderr, "Could not start scheduled playback - result = %08x\n", result);
			return result;
		}

		m_playbackRunning = true;
		return S_OK;
	}

	HRESULT ScheduleNextFrame(IDeckLinkVideoFrame* videoFrame)
	{
		HRESULT result = S_OK;

		BMDTimeValue streamTime = m_scheduledFrameCount * kFrameDuration;

		// Schedule the next output frame
		result = m_deckLinkOutput->ScheduleVideoFrame(videoFrame, streamTime, kFrameDuration, kTimeScale);
		if (result != S_OK)
		{
			fprintf(stderr, "Could not schedule video frame = %08x\n", result);
			return result;
		}

		m_scheduledFrameCount++;

		printf("Scheduled : Frame %p at %lld\n", videoFrame, (long long int)streamTime);

		return result;
	}

	// IDeckLinkVideoOutputCallback
	HRESULT	STDMETHODCALLTYPE ScheduledFrameCompleted(IDeckLinkVideoFrame* completedFrame, BMDOutputFrameCompletionResult completionResult) override
	{
		HRESULT result = S_OK;

		printf("Frame %p - (%s)\n", completedFrame, kVideoOutputCompletionResult[completionResult]);

		if (m_playbackRunning)
			result = ScheduleNextFrame(completedFrame);
		else
			completedFrame->Release();

		return result;
	}

	HRESULT StopPlayback()
	{
		HRESULT result;

		// Stop playback
		printf("Stopping scheduled playback ...\n");
		m_playbackRunning = false;

		result = m_deckLinkOutput->StopScheduledPlayback(0, NULL, 0);
		if (result != S_OK)
		{
			fprintf(stderr, "Could notstop scheduled playback - result = %08x\n", result);
			return result;
		}

		{
			// Wait for scheduled playback to stop
			std::unique_lock<std::mutex> lock(m_mutex);
			m_stoppedCondition.wait(lock);
		}

		// Disable the video output interface (pending scheduled frames will be flushed)
		result = m_deckLinkOutput->DisableVideoOutput();
		if (result != S_OK)
		{
			fprintf(stderr, "Could not disable video output - result = %08x\n", result);
			return result;
		}

		result = m_deckLinkOutput->SetScheduledFrameCompletionCallback(NULL);
		if (result != S_OK)
			fprintf(stderr, "Could not set scheduled frame completion callback - result = %08x\n", result);

		return result;
	}

	HRESULT	STDMETHODCALLTYPE ScheduledPlaybackHasStopped() override
	{
		printf("Scheduled playback has stopped.\n");

		std::lock_guard<std::mutex> guard(m_mutex);
		m_stoppedCondition.notify_all();

		return S_OK;
	}

	// IUnknown
	HRESULT	STDMETHODCALLTYPE QueryInterface (REFIID iid, LPVOID *ppv) override
	{
		*ppv = NULL;
		return E_NOINTERFACE;
	}

	ULONG STDMETHODCALLTYPE AddRef() override
	{
		return ++m_refCount;
	}

	ULONG STDMETHODCALLTYPE Release() override
	{
		ULONG refCount = --m_refCount;
		if (refCount == 0)
		{
			delete this;
			return 0;
		}

		return refCount;
	}
};

int main(int argc, const char * argv[])
{
	int				result = EXIT_FAILURE;
	IDeckLink*		deckLink = NULL;
	VideoOutput*	videoOutput = NULL;

#ifdef _WIN32
	// Initialize COM on this thread
	result = CoInitialize(NULL);
	if (FAILED(result))
	{
		fprintf(stderr, "Initialization of COM failed - result = %08x.\n", result);
		goto bail;
	}
#endif

	deckLink = GetFirstDeckLink();
	if (deckLink == NULL)
		goto bail;

	videoOutput =  new VideoOutput(deckLink);
	if (videoOutput == NULL)
	{
		fprintf(stderr, "Could not create video output object - result = %08x\n", result);
		goto bail;
	}

	if (videoOutput->EnableOutput() != S_OK)
		goto bail;

	if (videoOutput->PrerollAndStartScheduledPlayback() != S_OK)
		goto bail;

	// Wait for user input
	printf("Playing ... Press <RETURN> to stop\n");

	getchar();

	if (videoOutput->StopPlayback() != S_OK)
		goto bail;

	printf("Playback stopped. Press <RETURN> to exit\n");

	getchar();

	result = EXIT_SUCCESS;

bail:
	if (deckLink != NULL)
		deckLink->Release();

	delete videoOutput;

#ifdef _WIN32
	// Shutdown COM on this thread
	CoUninitialize();
#endif

	return result;
}
